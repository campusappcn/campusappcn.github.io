<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>分享一些iOS方面的小东西1 | Spacetime</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">分享一些iOS方面的小东西1</h1><a id="logo" href="/.">Spacetime</a><p class="description">Blogs from campusapp.cn's crazy developers</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">分享一些iOS方面的小东西1</h1><div class="post-meta">2016-02-21 | <span class="categories">分类于<a href="/categories/blog/"> blog</a></span></div><div class="post-content"><p>大致总结下去年，虽然忙忙忙，但是其中还是有不少的收获。那么我就分享一点收获吧~<br>先说下之前项目中让我印象最深刻的两个坑吧。（虽然是很小的两个点，但是个人认为还是比较难发现的。）</p>
<h4 id="坑1"><a href="#坑1" class="headerlink" title="坑1:"></a>坑1:</h4><p>之前碰到过一个问题是关于debug和release环境下不同的问题，看下面的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL x;</span><br><span class="line">int  a = 2;</span><br><span class="line">if (a==1) &#123;</span><br><span class="line">    x = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么猜测下打印出来的x是值是多少呢</p>
<h5 id="结果是在debug环境下是-0-而在release环境下是1"><a href="#结果是在debug环境下是-0-而在release环境下是1" class="headerlink" title="结果是在debug环境下是 0 而在release环境下是1"></a>结果是在debug环境下是 0 而在release环境下是1</h5><p>原因主要是release环境下，会给未复制的变量 按照意愿复制，而以上代码会给x事先复制YES</p>
<p>所以在之后的过程中 我会尽量给变量复制初始值，可以避免这类问题的出现，而且这类问题的排查起来也是很麻烦的，因为在debug环境下不会出现，只有在release环境下才会出现</p>
<h4 id="坑2："><a href="#坑2：" class="headerlink" title="坑2："></a>坑2：</h4><p>app中有时候会使用到coreData作为数据持久化的方式，一般coreData的保存 使用异步保存方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[_parentContext performBlock:^&#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>之前我们在项目中也会在app即将终止的回调中加入数据库的保存，希望能够把数据做保存。<br>然而如果在app即将终止的时候仍旧是用以上的方法，那么就会出现数据保存不了的情况。因为异步调用，app的生命周期会在其环节中的任何时候结束。所以这里要用同步的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [_parentContext performBlockAndWait:^&#123;</span><br><span class="line"> &#125;];</span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>对于工作中遇到的坑，以后我会继续福利给大家。</p>
<hr>
<p>下面分享一些之前看过的书中 我觉得比较适合的内容<br>前段时间刚看完的《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》这本书。<br>下面把部分觉得有意思的点拿出来分享下。</p>
<h4 id="1、在类的头文件中尽可能少引入其他的头文件"><a href="#1、在类的头文件中尽可能少引入其他的头文件" class="headerlink" title="1、在类的头文件中尽可能少引入其他的头文件"></a>1、在类的头文件中尽可能少引入其他的头文件</h4><p>少用#import xxx.h   如果正要用可以使用@class xxx<br>用@class 这种叫做“向前声明”该类<br>如果使用了import来引入 那么会引入.h中所以引入的内容，当然会增加编译时间，也许还会出现两个类相互引用的问题。</p>
<p>那么讲到这里 就有#import、@import、#include、@class这几个<br>#include 一般是c和c++的引入一般用<br>其中#import是objective-c中的一般引入类可以理解为include的改良版 确定文件只能被导入一次，不会在递归包含中出现问题<br>而@import 在xcode 5 下，为了更易于开发，增加了modules和 auto-linking 这两个新特性。用@import 来增加框架</p>
<h4 id="2、多用类型常量，少用-define预处理指令"><a href="#2、多用类型常量，少用-define预处理指令" class="headerlink" title="2、多用类型常量，少用#define预处理指令"></a>2、多用类型常量，少用#define预处理指令</h4><p>如#define XXX 0.3<br>这个预处理指令会把源代码中的XXX字符串替换为0.3。这样定义出来的常量没有类型信息，并且，预处理过长会把碰到的所有的xxx一律替换成0.3<br>相对来说在类中定义 static const NSTimeInterval xxx = 0.3; 这样更好一些。即定义了类型，同时也令代码的可阅读性加强<br>注：这里的变量xxx一定要同时用static 和 const 来声明。如果试图修改由const修饰符所声明的变量，那么编译器就会报错。而static修饰符则意味着该变量仅在定义此变量的编译单元中可见。因此如果在其他类中声明了同名的变量 也不会报错，</p>
<h4 id="3、少用try-catch"><a href="#3、少用try-catch" class="headerlink" title="3、少用try catch"></a>3、少用try catch</h4><p>在arc情况下 更容易造成内存泄露（具体原因如何就不说了），而且在控制包大小的时候，如果把项目中所有try catch去掉 在设置里吧开启trycatch的开关关掉，能缩减包的大小不少，但是由于经常会用到第三方的库，所以这一点很难把控。所以具体能减少多少，我也没有尝试过。</p>
<h4 id="4、用“自动释放池块”降低内存峰值"><a href="#4、用“自动释放池块”降低内存峰值" class="headerlink" title="4、用“自动释放池块”降低内存峰值"></a>4、用“自动释放池块”降低内存峰值</h4><p>objective-c对象的生命期取决于其引用计数。在objective-c的引用计数架构中，有一项特性叫做”自动释放池（autorelease pool）“。释放对象有两种方式：一种是调用release方法，十七保留计数立即递减；另一种是调用autorelease方法，将其加入”自动释放池“中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。清空（drain）自动释放池时，系统会向其中的对象发送release消息。<br>创建自动释放池所用语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>然而，一般情况下无须担心自动释放池的创建问题。系统会自动创建一些线程，比如主线程或gcd机制中的线程，这些线程默认都有自动释放池，每次执行“事件循环”时，就会将其清空。因此，不需要自己来创建“自动释放池块”，通常只有一个地方需要创建自动释放池，那就是main函数<br>但是下面这种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for （int i= 0; i &lt; 10000 ; i++）</span><br><span class="line">&#123;</span><br><span class="line">   [self doSomething:i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中doSomething: 方法如果要创建临时对象，那么这些对象很可能会放在自动释放池里，如果这些对象是一些临时字符串，那么即便在调用完方法之后就不再使用了，但是他们也依然是处于存活状态，因为目前还在自动释放池里，等待系统稍后将其释放回收。然而自动释放池要等线程执行下一次事件循环时才会情况，这意味着执行for循环时，会持续有新对象创建出来，并加入自动释放池中，所有这种对象都要等for循环执行完才会释放。这样一来，在执行for循环时，应用程序所占内存会持续上涨，而等到所有执行对象都释放后，内存又突然下降。这种情况不堪理想。<br>那么可以增加一个自动释放池来解决这个问题。如果把循环内的代码包裹在“自动释放池”中，那么在循环中自动释放的对象就会在这个池，而非线程的主池里面<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for （int i= 0; i &lt; 10000 ; i++）</span><br><span class="line">&#123;</span><br><span class="line">@autoreleasepool&#123;</span><br><span class="line">   [self doSomething:i];</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p>
<p>自动释放池机制就像“栈”一样。系统创建好自动释放池之后，就将其推入栈中，而清空自动释放池，则相当于将其从栈中弹出。在对象上执行自动释放操作，就相当于将其放入栈定的那个池里。</p>
<h4 id="5、用“僵尸对象”内存管理问题"><a href="#5、用“僵尸对象”内存管理问题" class="headerlink" title="5、用“僵尸对象”内存管理问题"></a>5、用“僵尸对象”内存管理问题</h4><p>僵尸对象Zombie Object</p>
<p>开发过程中经常会不经意间向已经回收的对象发送消息。然而这是不安全的，因为有时候可以，有时候不可以。具体可行与否，完全取决于对象所占内存有没有为其他内容所复写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔奔溃，在没有奔溃的情况下，那块内存可能只复用了其中一部分，所以对象中的某些二进制数据仍然有效。还有一种可能，那就是那块内存恰好为另外一个有效且存活的对象所占用。在这种情况下，运行期系统会把消息发到新内存对象那里，而此对象也许能应答，也许不能。如果能，那程序就不奔溃，如果不能则奔溃。<br>而cocoa提供了“僵尸对象”。启动这项调试功能后，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”，而不会真正回收他们。这种对象所在的核心内存无法重用，因此不可能遭到复写。僵尸对象受到消息后，会抛出异常，其中准确的说明了发送过来的消息，并描述了回收之前的那个对象。<br>因此“僵尸对象”也是一直debug的好方法，而且可以排查一些比较隐秘的bug。</p>
</div><div class="tags"><a href="/tags/Development/">Development</a><a href="/tags/iOS/">iOS</a><a href="/tags/tips/">tips</a></div><div class="post-nav"><a href="/2016/02/28/2016-02-28-Spring测试替换Bean (Mock)/" class="pre"><i class="icon-previous">Spring测试替换注入的Bean (Mock)</i></a><a href="/2016/02/20/吐槽一下阿里云图片服务/" class="next">吐槽一下阿里云图片服务<i class="icon-next"></i></a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://campusappcn.github.io"/></form></div><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="si" value="http://campusappcn.github.io"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/blog/">blog</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/xcode/" style="font-size: 15px;">xcode</a> <a href="/tags/Development/" style="font-size: 15px;">Development</a> <a href="/tags/hls/" style="font-size: 15px;">hls</a> <a href="/tags/live-stream/" style="font-size: 15px;">live-stream</a> <a href="/tags/安卓/" style="font-size: 15px;">安卓</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/自定义/" style="font-size: 15px;">自定义</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/状态保存/" style="font-size: 15px;">状态保存</a> <a href="/tags/阿里云/" style="font-size: 15px;">阿里云</a> <a href="/tags/图片/" style="font-size: 15px;">图片</a> <a href="/tags/rtmp/" style="font-size: 15px;">rtmp</a> <a href="/tags/buildSetting/" style="font-size: 15px;">buildSetting</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/ReactiveCocoa/" style="font-size: 15px;">ReactiveCocoa</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/Mock-bean/" style="font-size: 15px;">Mock bean</a> <a href="/tags/Injection/" style="font-size: 15px;">Injection</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/Java-web/" style="font-size: 15px;">Java web</a> <a href="/tags/Spring-MVC/" style="font-size: 15px;">Spring MVC</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/player/" style="font-size: 15px;">player</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/02/29/xcode的BuildSettings/">关于xcode的buildSettings</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/安卓自定义控件状态保存/">安卓自定义控件状态保存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/ReactiveCocoa2-5修炼-一/">ReactiveCocoa2.5修炼 (一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/2016-02-28-浅谈Android开发中多进程共享数据/">浅谈Android开发中多进程共享数据</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/2016-02-28-Spring测试替换Bean (Mock)/">Spring测试替换注入的Bean (Mock)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/2016-02-21-分享一些iOS方面的小东西1/">分享一些iOS方面的小东西1</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/20/吐槽一下阿里云图片服务/">吐槽一下阿里云图片服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/20/2016-02-20-Sping MVC HTTP请求参数劫持、修改/">Spring MVC HTTP请求参数劫持、修改</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/30/2016-01-30-Android使用FFMpeg实现推送视频直播流到服务器/">Android使用FFmpeg实现推送视频直播流到服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/30/2016-01-30-在各端实现Rtmp和hls流视频的播放/">在各端实现Rtmp和hls视频流的播放</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://campusapp.cn" title="官网" target="_blank">官网</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">Spacetime.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js"></script>
<script src="/js/totop.js"></script><script src="/js/fancybox.pack.js"></script>
<script src="/js/jquery.fancybox.js"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"></div></body></html>